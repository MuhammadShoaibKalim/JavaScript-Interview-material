# JavaScript Interview Preparation

Welcome to the JavaScript interview preparation repository! Here you'll find a curated collection of essential JavaScript concepts, along with common interview questions and their explanations.

## Try It Online

You can try out the JavaScript code snippets provided in this README.md file directly in your browser using the online compiler below.

[![Open in CodePen](https://img.shields.io/badge/Open_in-CodePen-000000?style=for-the-badge&logo=codepen)](https://codepen.io/pen?template=)

## Table of Contents

1. [Introduction to JavaScript](#introduction-to-javascript)
2. [Common JavaScript Interview Questions](#common-javascript-interview-questions)

## Introduction to JavaScript hello

JavaScript is a scripting language commonly used to create interactive web pages. It works alongside HTML and CSS to provide dynamic functionality and enhanced user experience.


**Interview asked Question**

```

Basic:
1- Can you explain the difference between HTML and CSS?

2How do you handle responsive design in web development?

3-What is JavaScript, and what are its main features?

4-What are the advantages of using Node.js?

5-What is the difference between GET and POST requests?

Medium:
6. What is a thread pool and which library handles it in Node.js??

7-How do you manage state in React?

8-Explain the concept of RESTful API.

9-How do you handle errors in JavaScript?

10- Can you demonstrate your experience with database management in Mongo DB?

Hard:
Scenario Question: Imagine you need to build a real-time chat application. How would you approach designing the backend architecture?

```

**Interview Question LinkedIn Resources asked**

```

**120+ React interview questions to practice to get hired in your next interview**

Save the post and reshare the post with other devs to help.

1. What is "key" prop and what is the benefit of using it in arrays of elements?

2. What is the purpose of callback function as an argument of setState()?

3. What is the purpose of using super constructor with props argument?

4. Which is preferred option with in callback refs and findDOMNode()?

5. What is the difference between createElement and cloneElement?

6. Why you get "Router may have only one child element" warning?

7. Why you get "Router may have only one child element" warning?

8. What is the difference between HTML and React event handling?

9. What is the difference between Shadow DOM and Virtual DOM?

10. How to pass params to history.push method in React Router v4?

11. How to pass params to history.push method in React Router v4?

12. How do you programmatically navigate using React router v4?

13. How do you programmatically navigate using React router v4?

14. When to use a Class Component over a Function Component?

15. When to use a Class Component over a Function Component?

16. What is the purpose of push and replace methods of history?

17. What is the purpose of push and replace methods of history?

18. What is the difference between Element and Component?

19. What is the difference between Element and Component?

20. How to pass a parameter to an event handler or callback?

21. How to bind methods or event handlers in JSX callbacks?

22. What are the different phases of component lifecycle?

23. How React Router is different from history library?

24. How React Router is different from history library?

25. How to create props proxy for HOC component?

26. What is the difference between state and props?

27. How to get query parameters in React Router v4

28. How to get query parameters in React Router v4

29. How to implement default or NotFound page?

30. How to implement default or NotFound page?

31. What are the <Router> components of React Router v4?

32. What are the <Router> components of React Router v4?

33. Why should we not update the state directly?

34. What are the lifecycle methods of React?

35. What are inline conditional expressions?

36. How to get history on React Router v4?

37. How to get history on React Router v4?

38. What are Higher-Order components?

39. What is the main goal of React Fiber?

40. How to create components in React?

41. What are the lifecycle methods of React?

42. What are uncontrolled components?

43. What are synthetic events in React?

44. What are controlled components?

45. How to write comments in React?

46. What is Lifting State Up in React?

47. What are Pure Components?

48. What are Pure Components?

49. Why are String Refs legacy?

50. How Virtual DOM works?

51. What are props in React?

52. What is the use of refs?

```
/////////////////////////////////////////////////////////

**Most asked 52 #reactjs interview questions:**

```
1. What is React?
2. What is useMemo ?
3. What are the features of React ?
4. What is JSX ?
5. What is DOM ?
6. What is Virtual Dom ?
7. What is component life cycle of React class component ?
8. What are fragments in react ?
9. What are props in react ?
10. What are synthetic events in react ?
11. What are the difference between Package.json and Package.lock.json ?
12. What are the differences between client side and server side rendering ?
13. What is state in Reactjs?
14. What are props ?
15. What are the differences between State and Props in react ?
16. What is props drilling ?
17. What are the disadvantages of props drilling and How we can avoid props drilling ?
18. What are Pure components in React ?
19. Whatare Ref‚Äôs in React?
20. What is meant by forward ref ?
21. What are Error boundaries ?
22. What are Higher order components in react ?
23. What are the differences between controlled and uncontrolled components ?
24. What is useCallback ?
25. What are the differences between useMemo and useCallback ?
26. What are keys in React ?
27. What is Lazy loading in React ?
28. What is suspense in React ?
29. What are custom hooks ?
30. What is useReducer hook ?
31. What are Portals in react ?
32. What is context in react ?
33. Practical question: Give an example of context api usage ?
34. What is the purpose of callback function as an argument of setState()?
35. Practical question: create a custom hook for increment/decrement counter ?
36. Which lifecycle hooks in class component are replaced with useEffect in functional components ?
37. What is Strict mode in react ?
38. What are the different ways to pass data from child component to parent component in react ?
39. Practical question: How to send data from child to parent using callback functions ?
40. Practical question: How to send the data from child component to parent using useRef ?
41. How do you optimize your react application ?
42. How would you consume a RESTful JSON API in reactjs?
43.different design patterns used in react?
44. context api vs redux
45. prop types in react(How to apply validation on props in react)
46. What are React Mixins ?
47. what are the different hooks you have used ?
48. What are render props in react ?
49. What are the different types of exports and imports ?
50. What are the differences between create element vs clone element in react ?
51. When to use useState and useReducer?
52. What is flushSync in react ?

just at 45rs, get ebook with (detailed 142 ques = 42 Reactjs Frequent Ques & Answers, 50+ frequently asked interview questions and answers, 23+ Output based ques & ans, 22+ Coding Questions & ans)
ùêÑùêõùê®ùê®ùê§ ùêãùê¢ùêßùê§: https://lnkd.in/gJMmH-PF

```

**Interview asked Questions**

```

Level-1: Basic
1. Is Javascript single-threaded?

2. Explain the main component of the JavaScript Engine and how it works.

3. Explain the event loop in JavaScript and how it helps in asynchronous programming.

4. Difference between var, let, and const ?

5. Different data types in Javascript?

6. What is callback function and callback hell ?

7. What is Promise and Promise chaining?

8. What is async/await ?

9.What is the difference between == and === operators ?

10. Different ways to create an Object in Javascript ?

11. What is rest and spread operator?

12. What is a higher-order function?

Level-2 : Intermediate
13. What is Closure? What are the use cases of Closures?

14. Explain the concept of hoisting in JavaScript.

15. What is a Temporal dead zone?

16. What is a prototype chain? and Object.create() method?

17. What is the difference between Call, Apply, and Bind methods?

18. What are lambda or arrow functions?

19. What is the currying function?

20. What are the features of ES6?

Level-3: Expert
21. What is Execution context, execution stack, variable object, scope chain?

22. What is the priority of execution of callback, promise, setTimeout, process.nextTick()?

23. What is the Factory function and generator function?

24. Different ways to clone (Shallow and deep copy of object) an object?

25. How to make an object immutable? (seal and freeze methods)?

26. What is Event and event flow, event bubbling and event capturing?

27. What is Event delegation?

28. What are server-sent events?

29. What is a web worker or service worker in javascript?

30. How to compare 2 JSON objects in javascript?

Sources:
https://medium.com/@javascriptcentric/top-30-javascript-interview-questions-and-answers-for-2024-7f1e2d1d0638
```


## Common JavaScript Interview Questions

```//////////Context Api ///////

import React from "react";
import UserContextProvider from "./context/UserContextProvider";
import Profile from "./components/Profile";
import Login from "./components/Login";


function App() {
   
  return (
    <UserContextProvider>
        <h2>Hello User context api</h2>
        <Login/>
        <Profile/>
       
    </UserContextProvider>
  )
}

export default App;


//////////////////////////////////////////////////////

import React from "react";
import UserContext from "./UserContextApi";


const UserContextProvider = ({children}) =>{
    const [user, setUser] = React.useState(null);

    return(
      <UserContext.Provider value={{user, setUser}}>
         <children/>
      </UserContext.Provider>
    );
}

export default UserContextProvider;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

import React from "react";
import UserContext from "./UserContextApi";

const UserContextProvider = ({ children }) => {
  const [user, setUser] = React.useState(null);

  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
};

export default UserContextProvider;

=====================================================

import React, { useContext } from 'react';
import UserContext from '../context/UserContextApi';

const Profile = () => {
  const { user } = useContext(UserContext);

  if (!user) {
    return <div>Please login to continue.</div>;
  } else {
    return <div>Welcome {user.username}</div>;
  }
};

export default Profile;


====================================================
import React, { useContext, useState } from 'react';
import UserContext from '../context/UserContextApi';

const Login = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const { setUser } = useContext(UserContext);

  const handleClick = (e) => {
    e.preventDefault();
    setUser({ username, password });
  };

  return (
    <div>
      <h1>Login</h1>
      <input
        type='text'
        placeholder='Username'
        value={username}
        onChange={(e) => setUsername(e.target.value)}
      />
      <input
        type='password'
        placeholder='Password'
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <button onClick={handleClick}>Submit</button>
    </div>
  );
};

export default Login;

==============================================================================================
import React from "react";

const userContext =React.createElement();
export default userContext;

==============================================================================================
```
1. **Difference between == and ===**
   - `==` is used for value equality, while `===` is used for both value and type equality.
   - `==` performs type coercion, converting the types of operands to match, while `===` requires both operands to have the same type without coercion.
   - **Example:**
     ```javascript
     console.log(1 == '1'); // true
     console.log(1 === '1'); // false
     ```

2. **Primitive and non-primitive data types**
   - **Primitive data types**: These are immutable data types and include string, number, boolean, null, undefined, and symbol.
   - **Non-primitive data types**: Also known as reference types, these include objects and arrays. They are mutable and stored by reference.
   - **Example:**
     ```javascript
     let primitive = 'Hello';
     let nonPrimitive = [1, 2, 3];
     ```

3. **Use of ‚Äòthis‚Äô keyword**
   - `this` refers to the object it belongs to.
   - Its value is determined by how a function is called.
   - **Example:**
     ```javascript
     const obj = {
       name: 'John',
       greet: function() {
         console.log('Hello, ' + this.name);
       }
     };
     obj.greet(); // Hello, John
     ```

4. **Difference between Regular JavaScript functions and arrow functions**
   - Regular functions:
     - Have their own `this` binding.
     - Cannot be used as constructors with `new`.
   - Arrow functions:
     - Lexically bind `this` to the surrounding execution context.
     - Cannot be bound with `new` or used as constructors.
   - **Example:**
     ```javascript
     const regularFunc = function() {
       console.log(this);
     };

     const arrowFunc = () => {
       console.log(this);
     };

     regularFunc(); // Logs the global object
     arrowFunc(); // Logs the lexical `this`
     ```

5. **Closures**
   - A closure is a function that retains access to variables from its lexical scope even after the scope has exited.
   - It allows functions to maintain access to variables from outer scopes in which they were defined.
   - **Example:**
     ```javascript
     function outerFunction() {
       let outerVar = 'I am outer';

       function innerFunction() {
         console.log(outerVar);
       }

       return innerFunction;
     }

     const closureFunc = outerFunction();
     closureFunc(); // Logs 'I am outer'
     ```

6. **Hoisting**
   - Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their containing scope during the compilation phase.
   - This allows variables to be used before they are declared.
   - **Example:**
     ```javascript
     console.log(x); // undefined
     var x = 5;
     ```

7. **Promises**
   - Promises are objects representing the eventual completion or failure of an asynchronous operation.
   - They provide a cleaner alternative to callback-based asynchronous code.
   - Promises have three states: pending, fulfilled, or rejected.
   - **Example:**
     ```javascript
     const promise = new Promise((resolve, reject) => {
       setTimeout(() => {
         resolve('Promise resolved');
       }, 2000);
     });

     promise.then((result) => {
       console.log(result); // Logs 'Promise resolved' after 2 seconds
     });
     ```

8. **Difference between let, var, and const**
   - `var`: Function-scoped variable declaration, hoisted to the top of its function or global scope.
   - `let`: Block-scoped variable declaration, not hoisted, can be reassigned.
   - `const`: Block-scoped variable declaration, not hoisted, cannot be reassigned (but its properties can be modified for objects and arrays).
   - **Example:**
     ```javascript
     var a = 10;
     let b = 20;
     const c = 30;

     function example() {
       console.log(a, b, c);
     }

     example(); // Logs 10 20 30
     ```

9. **Destructuring**
   - Destructuring is a JavaScript expression that makes it possible to unpack values from arrays or properties from objects into distinct variables.
   - It offers a concise way to extract multiple values from data stored in objects and arrays.
   - **Example:**
     ```javascript
     const person = { name: 'John', age: 30 };
     const { name, age } = person;
     console.log(name, age); // Logs 'John 30'
     ```

10. **Prototype Chain**
    - The prototype chain is a mechanism in JavaScript where objects inherit properties and methods from their prototype object.
    - It allows objects to delegate behavior to their prototype, enabling inheritance in JavaScript.
    - **Example:**
      ```javascript
      function Animal(name) {
        this.name = name;
      }

      Animal.prototype.sayName = function() {
        console.log('My name is ' + this.name);
      };

      const dog = new Animal('Buddy');
      dog.sayName(); // Logs 'My name is Buddy'
      ```

11. **Asynchronous**
    - Asynchronous programming allows multiple tasks to be executed concurrently without blocking the main thread.
    - It is essential for handling time-consuming operations like network requests, file I/O, and user input/output.
    - **Example:**
      ```javascript
      setTimeout(() => {
        console.log('Async operation');
      }, 2000);
      ```

12. **New features in ES6**
    - ES6 introduced several new features such as arrow functions, template literals, destructuring, default parameters, rest parameters, spread syntax, classes, and more.
    - **Example:**
      ```javascript
      const greeting = (name) => {
        return `Hello, ${name}!`;
      };

      console.log(greeting('World')); // Logs 'Hello, World!'
      ```

13. **Event bubbling and capturing**
    - Event bubbling is a phenomenon in which an event triggered on a nested element propagates up through its ancestors.
    - Event capturing is the opposite, where the event starts from the outermost element and propagates downwards to the target element.
    - **Example:**
      ```html
      <div id="outer">
        <div id="inner">Click me!</div>
      </div>
      ```
      ```javascript
      document.getElementById('outer').addEventListener('click', () => {
        console.log('Outer div clicked');
      }, true);

      document.getElementById('inner').addEventListener('click', () => {
        console.log('Inner div clicked');
      }, true);
      ```

14. **Null vs Undefined**
    - `null` represents the intentional absence of any value and is a primitive value.
    - `undefined` indicates that a variable has been declared but has not been assigned a value, or a property does not exist.
    - **Example:**
      ```javascript
      let x;
      console.log(x); // Logs undefined

      const y = null;
      console.log(y); // Logs null
      ```

15. **Function expression vs function declaration**
    - Function declaration: Function declarations are hoisted and can be invoked before they're declared in the code.
    - Function expression: Function expressions are not hoisted and cannot be invoked before their declaration.
    - **Example:**
      ```javascript
      functionDeclaration(); // Logs 'Function declaration'

      const functionExpression = function() {
        console.log('Function expression');
      };

      functionDeclaration(); // Logs 'Function declaration'
      ```
16. **Call, apply, bind**
    - `call()` and `apply()`: These methods are used to invoke a function with a specified `this` value and arguments.
    - `bind()`: This method creates a new function with a specified `this` value and, optionally, a set of initial arguments.
    - **Example:**
      ```javascript
      const person = {
        name: 'John',
        greet: function(message) {
          console.log(message + ', ' + this.name);
        }
      };

      const newPerson = { name: 'Alice' };

      person.greet.call(newPerson, 'Hello'); // Logs 'Hello, Alice'
      ```

17. **ES6 arrow function vs normal function**
    - Arrow functions are more concise and lexically bind `this` to the surrounding context.
    - Normal functions have their own `this` context and can be used as constructors with `new`.
    - **Example:**
      ```javascript
      const multiply = (x, y) => x * y;
      console.log(multiply(2, 3)); // Logs 6

      function Product(name, price) {
        this.name = name;
        this.price = price;
      }

      const apple = new Product('Apple', 1);
      console.log(apple); // Logs { name: 'Apple', price: 1 }
     ```

     # ES6 Features and JavaScript Concepts
     
18. **ES6 Features**
- Let and const keywords.
- Arrow functions.
- Multi-line Strings.
- The destructuring assignment.
- Enhanced object literals.
- Promises.

19. **Difference between var, const, and let**
- Variables declared with let and const are block-scoped; Variables declared with var are globally-scoped or function-scoped.
- var variables can be updated and re-declared within its scope; let variables can be updated but not re-declared; const variables can neither be updated nor re-declared.
- var can be hoisted to the top of their scope. Where var variables are initialised as undefined, let and const variables are not initialised(Temporary Dead Zone, TDZ).
- While var and let can be declared without being initialised, const must be initialised during declaration.

 20. **Promises and Async-Await**
- Promises enable asynchronous programming in JavaScript, allowing a program to call a function with the expectation that it will return a result for further computation.
- Async-await is syntactic sugar for promises, simplifying asynchronous programming and preventing callback hell.

```javascript
const myPromise = new Promise((resolve, reject) => { 
    // promise condition
});
```

 21. **How does JavaScript maintain concurrency?**
- Event Loop.
- Micro & Macro Queue.
- Callback.
- Thread Pool & Clustering (Multi-Threading).

22. **What is a callback and how does it work behind the scene?**
- The callback is possible only because JavaScript supports the first-class function.
- A function that has passed as an argument to another function or it can be executed in that other function is called a callback.
- In Node.js, it consists of 4 default threads that are responsible for maintaining the main stack and other queues, most asynchronous functions call other asynchronous functions and then call the callback. You can think of it as a chain of functions and callbacks. All asynchronous and IO operations are directly not handled by the main thread, All callbacks and asynchronous calls have been handled by the other queue which presents in the JS engine.

23. **How many ways do we have for declaring a function and how are they different from each other?**
- A function declaration has made of a function keyword, followed by an obligatory function name, a list of parameters in a pair of parenthesis.
- Shorthand method definition can be possible to use in a method declaration on object literals and ES2015 classes.
- An Arrow function is defined using a pair of parenthesis that contains the list of parameters. Followed by a fat arrow => and a pair of curly braces that delimits the body statements.
- In a function expression, you assign a function to a variable.
- A function can be dynamically created using the Function constructor, but it suffers from security and performance issues and is not advisable to use.

24. **Output of Code**

```javascript
x = 5;
var x;
(function fun() { 
    {
        let x = 1;
        x++;
        console.log(x);
    }
    console.log(x);
})();
```
25.  **What is the difference between Java and JavaScript?**
    
     Java and JavaScript are unrelated programming languages. Java is an object-based, strongly typed language. It's used in app development and runs on a virtual machine.
     It's also known for block scoping and thread- based concurrency, which consumes more memory. In contrast, JavaScript is an object-oriented, dynamically typed language.
     JavaScript is used for web applications in browsers and Node.js environments. It utilizes function-scoping event-based concurrency and is more memory-efficient. This
      makes it ideal for web pages. The key differences lie in typing, scoping, concurrency models, and memory usage.
     
      
27. **What is is JSON in JavaScript**
    
      Javascript Object Notation (JSON) is a standard text-based format in web applications. Its function is to represent structured data using JavaScript object syntax.
      It transmits data between a server and a client, enabling seamless data display on web pages. JSON is a text file with a .json extension and an 'application/json'
      MIME type, making it ideal for network data transfer.In practice, JSON operates through two key processes: parsing and stringification. Parsing involves converting
      a string into a native object using JSON.parse(text). Stringification is the reverse. It transforms a native object into a string with JSON.stringify(object) for
      network transmission. This dual functionality makes 
      JSON a versatile tool in web development.
    
    
29.   **Explain how cookies work in JavaScript?**
    
       Cookies in JavaScript function as a way to store user information (like usernames) between web sessions. When a server sends data to a visitor's browser, the data may
       include a cookie. If the browser accepts this okie, it's saved as a plain text file on the visitor's hard drive. Upon later visits to the same site, the browser returns
       this cookie to the server. This process lows the server to retrieve the stored formation to enable a seamless user experience.

30. **What is the primary goal of React Fiber, and how does it aim to achieve it?**

      The primary goal of React Fiber is to increase React's suitability for areas like animation, layout, and gestures by enabling incremental rendering. This means splitting rendering work into chunks spread out over 
       multiple frames. Additionally, Fiber aims to introduce features such as pausing, aborting, or reusing work as new updates come in, assigning priority to different types of updates, and implementing newconcurrency 
      primitives.

 31 **What is reconciliation in React, and why is it essential?**

 Reconciliation is the algorithm used by React to diff one tree with another, determining which parts need to be changed. It's crucial because it allows React to update the user interface efficiently by computing only the necessary changes instead of re-rendering the entire application on every update.

32. **How does React separate reconciliation from rendering, and why is this separation important?**

React separates reconciliation, which computes which parts of the tree have changed, from rendering, which updates the rendered application. This separation allows React to support various rendering environments, such as the DOM and React Native while using the same reconciler. It also enables optimizations and flexibility in scheduling updates, contributing to a smoother user experience.

33. **What is scheduling in React, and why does React use a pull-based approach?**

Scheduling in React refers to the process of determining when work should be performed, and prioritizing different types of updates. React utilizes a pull-based approach where computations can be delayed until necessary, allowing the framework to make smart decisions about when to execute work based on factors like user interactions and frame rates. This approach avoids unnecessary work and optimizes performance by deferring updates until they are needed.

 34. **What is a fiber in React Fiber's architecture, and why is it essential?**

Answer: In React Fiber, a fiber represents a unit of work, allowing React to break rendering work into incremental units for better control over scheduling and performance. Fibers enable React to pause, resume, prioritize, and reuse work, contributing to features like incremental rendering and concurrency. They serve as virtual stack frames, allowing React to optimize rendering for user interfaces effectively.    


35. **What are the common JavaScript data types?**
    
When answering this question, give an example for each data type if possible.
Example: Common JavaScript data types are boolean, number, object, string and undefined. These can be divided into three categories of primitive, composite and special.


36. **How do a confirmation box and alert box vary?**
    
JS interviewers ask this question to know how effectively could you create code that simplifies the message for the user.
Example: Both these boxes are used to communicate a message to the user. While the alert box has only one option to click on (OK), the confirmation box has two (OK and CANCEL).


37. **Name the three pop-up boxes that exist in JS**
    
This question indicates your ability to create interactive and followable interfaces for users.
Example: The three pop-up boxes in JS include Alert, Confirm, and Prompt.


38. **What are two ways to read and write a file using JS?**
    
This JS interview question helps analyze your basic usability metric with the programming language.
Example: A file can be read or written on JS through either a webpage and Active X objects, or JS extensions.


39. **What exactly are global variables?**
    
This tests the candidate's insights on reducing the usage of local variables and saving up on memory.
Example: If the var keyword, which is used to declare a locale object or variable, is omitted, then a global variable is declared. Additionally, 
global variables exist all across the code to eliminate any limitations.


40. **What does negative infinity mean in JS?**

    
Despite being more of a value-related answer, negative infinity also helps in looping.
Example: When any negative number is divided by zero, you get a JS number called negative infinity. Also, when divided by itself, it returns NaN.


41. **What is the NaN property in JavaScript?**

    
NaN stands for ‚Äúnot a number‚Äù and can help identify whether a value is a valid number or not. For example, finding the square root of a negative number returns NaN.
Example: NaN represents non-number values. Simply put, it helps identify invalid numbers.


42. **Name the three looping structures in JS**

    
Loops are a highly utilized feature in any programming language and indicate the coder's ability to cut down longer codes into shorter ones.
Example: For, While and Do-while are the three looping structures.


43. **What would be the output of 5+9+‚Äù2‚Äù in JS?**

    
This question tests your idea of how numeric calculations occur in JS programming.
Example: As 2 is placed within a string, it would be concatenated to the sum of 5+9. Thus, the output is 142.

44. **What is DOM in JavaScript?**

    
DOM helps in managing web documents through code. Using DOM in JS, the coder gets access to the components of a webpage.
Example: Document Object Model is automatically created by the web browser once the page has loaded. Each and every element of the webpage can be accessed, and modified from the DOM.


45. **What are the window.onload and onDocumentReady features?**
Both these functions are related to the loading of the webpage and code. Explain your answers in terms of which feature manipulates the code quicker.
Example: While onDocumentReady downloads the code right before the DOM is ready, it permits the coder to manipulate the code early. Whereas, window.onload does not begin till all webpage information isn't ready. Moreover, it causes delays before the code is run.


47. **What are the 3 types of errors in JavaScript?**

    
These errors are automatically generated and categorised into three types. If you can portray your code-resolving abilities with a diversified knowledge of how these errors arise then you would be able to create a good impression.
Example: The three error types in JS are Load-time, Runtime and Logic errors. Any of these errors would interrupt the smooth functioning of the program.

48. **Name the two basic groups of data types in JS**
    
This explains your flexibility when it comes to using a large variety and number of variables.
Example: The two basic groups of data types in JS are Primitive and Reference types. Primitive types represent only number and Boolean types, whereas reference types consist of more complex data types such as strings and dates.

49. **Explain the event delegation model in JavaScript.**
Event delegation is a technique involving adding a single event listener to a parent element that catches all events of a specific type from its child elements.
This is useful for handling dynamically added elements or reducing the number of event listeners.

```document.getElementById("parent").addEventListener("click", function(e) {
  if (e.target && e.target.nodeName === "LI") {
    console.log("List item clicked!");
  }
});
```

50. **How do you implement inheritance in JavaScript?**

Inheritance in JavaScript can be implemented using prototype chaining, where an object inherits properties and methods from another object.
Example:

```function Animal(name) {
  this.name = name;
}
Animal.prototype.speak = function() {
  console.log(this.name + ' makes a noise.');
}

function Dog(name) {
  Animal.call(this, name);
}
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

const dog = new Dog('Rex');
dog.speak(); // Rex makes a noise.
```


      
### Coding Exercise

#### 1. What is the output of the below code

```javascript
var car = new Vehicle("Honda", "white", "2010", "UK");
console.log(car);

function Vehicle(model, color, year, country) {
  this.model = model;
  this.color = color;
  this.year = year;
  this.country = country;
}
```

- 1: Undefined
- 2: ReferenceError
- 3: null
- 4: {model: "Honda", color: "white", year: "2010", country: "UK"}

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The function declarations are hoisted similar to any variables. So the placement for `Vehicle` function declaration doesn't make any difference.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 2. What is the output of below code

```javascript
function foo() {
  let x = (y = 0);
  x++;
  y++;
  return x;
}

console.log(foo(), typeof x, typeof y);
```

- 1: 1, undefined and undefined
- 2: ReferenceError: X is not defined
- 3: 1, undefined and number
- 4: 1, number and number

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

Of course the return value of `foo()` is 1 due to the increment operator. But the statement `let x = y = 0` declares a local variable x. Whereas y declared as a global variable accidentally. This statement is equivalent to,

```javascript
let x;
window.y = 0;
x = window.y;
```

Since the block scoped variable x is undefined outside of the function, the type will be undefined too. Whereas the global variable `y` is available outside the function, the value is 0 and type is number.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 3. What is the output of below code

```javascript
function main() {
  console.log("A");
  setTimeout(function print() {
    console.log("B");
  }, 0);
  console.log("C");
}
main();
```

- 1: A, B and C
- 2: B, A and C
- 3: A and C
- 4: A, C and B

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The statements order is based on the event loop mechanism. The order of statements follows the below order,

1. At first, the main function is pushed to the stack.
2. Then the browser pushes the first statement of the main function( i.e, A's console.log) to the stack, executing and popping out immediately.
3. But `setTimeout` statement moved to Browser API to apply the delay for callback.
4. In the meantime, C's console.log added to stack, executed and popped out.
5. The callback of `setTimeout` moved from Browser API to message queue.
6. The `main` function popped out from stack because there are no statements to execute
7. The callback moved from message queue to the stack since the stack is empty.
8. The `console.log` for B is added to the stack and display on the console.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 4. What is the output of below equality check

```javascript
console.log(0.1 + 0.2 === 0.3);
```

- 1: false
- 2: true

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

This is due to the float point math problem. Since the floating point numbers are encoded in binary format, the addition operations on them lead to rounding errors. Hence, the comparison of floating points doesn't give expected results.
You can find more details about the explanation here [0.30000000000000004.com/](https://0.30000000000000004.com/)

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 5. What is the output of below code

```javascript
var y = 1;
if (function f() {}) {
  y += typeof f;
}
console.log(y);
```

- 1: 1function
- 2: 1object
- 3: ReferenceError
- 4: 1undefined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The main points in the above code snippets are,

1. You can see function expression instead function declaration inside if statement. So it always returns true.
2. Since it is not declared(or assigned) anywhere, f is undefined and typeof f is undefined too.

In other words, it is same as

```javascript
var y = 1;
if ("foo") {
  y += typeof f;
}
console.log(y);
```

**Note:** It returns 1object for MS Edge browser

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 6. What is the output of below code

```javascript
function foo() {
  return;
  {
    message: "Hello World";
  }
}
console.log(foo());
```

- 1: Hello World
- 2: Object {message: "Hello World"}
- 3: Undefined
- 4: SyntaxError

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

This is a semicolon issue. Normally semicolons are optional in JavaScript. So if there are any statements(in this case, return) missing semicolon, it is automatically inserted immediately. Hence, the function returned as undefined.

Whereas if the opening curly brace is along with the return keyword then the function is going to be returned as expected.

```javascript
function foo() {
  return {
    message: "Hello World",
  };
}
console.log(foo()); // {message: "Hello World"}
```

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 7. What is the output of below code

```javascript
var myChars = ["a", "b", "c", "d"];
delete myChars[0];
console.log(myChars);
console.log(myChars[0]);
console.log(myChars.length);
```

- 1: [empty, 'b', 'c', 'd'], empty, 3
- 2: [null, 'b', 'c', 'd'], empty, 3
- 3: [empty, 'b', 'c', 'd'], undefined, 4
- 4: [null, 'b', 'c', 'd'], undefined, 4

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

The `delete` operator will delete the object property but it will not reindex the array or change its length. So the number or elements or length of the array won't be changed.
If you try to print myChars then you can observe that it doesn't set an undefined value, rather the property is removed from the array. The newer versions of Chrome use `empty` instead of `undefined` to make the difference a bit clearer.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 8. What is the output of below code in latest Chrome

```javascript
var array1 = new Array(3);
console.log(array1);

var array2 = [];
array2[2] = 100;
console.log(array2);

var array3 = [, , ,];
console.log(array3);
```

- 1: [undefined √ó 3], [undefined √ó 2, 100], [undefined √ó 3]
- 2: [empty √ó 3], [empty √ó 2, 100], [empty √ó 3]
- 3: [null √ó 3], [null √ó 2, 100], [null √ó 3]
- 4: [], [100], []

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

The latest chrome versions display `sparse array`(they are filled with holes) using this empty x n notation. Whereas the older versions have undefined x n notation.
**Note:** The latest version of FF displays `n empty slots` notation.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 9. What is the output of below code

```javascript
const obj = {
  prop1: function () {
    return 0;
  },
  prop2() {
    return 1;
  },
  ["prop" + 3]() {
    return 2;
  },
};

console.log(obj.prop1());
console.log(obj.prop2());
console.log(obj.prop3());
```

- 1: 0, 1, 2
- 2: 0, { return 1 }, 2
- 3: 0, { return 1 }, { return 2 }
- 4: 0, 1, undefined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

ES6 provides method definitions and property shorthands for objects. So both prop2 and prop3 are treated as regular function values.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 10. What is the output of below code

```javascript
console.log(1 < 2 < 3);
console.log(3 > 2 > 1);
```

- 1: true, true
- 2: true, false
- 3: SyntaxError, SyntaxError,
- 4: false, false

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

The important point is that if the statement contains the same operators(e.g, < or >) then it can be evaluated from left to right.
The first statement follows the below order,

1. console.log(1 < 2 < 3);
2. console.log(true < 3);
3. console.log(1 < 3); // True converted as `1` during comparison
4. True

Whereas the second statement follows the below order,

1. console.log(3 > 2 > 1);
2. console.log(true > 1);
3. console.log(1 > 1); // False converted as `0` during comparison
4. False

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 11. What is the output of below code in non-strict mode

```javascript
function printNumbers(first, second, first) {
  console.log(first, second, first);
}
printNumbers(1, 2, 3);
```

- 1: 1, 2, 3
- 2: 3, 2, 3
- 3: SyntaxError: Duplicate parameter name not allowed in this context
- 4: 1, 2, 1

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

In non-strict mode, the regular JavaScript functions allow duplicate named parameters. The above code snippet has duplicate parameters on 1st and 3rd parameters.
The value of the first parameter is mapped to the third argument which is passed to the function. Hence, the 3rd argument overrides the first parameter.

**Note:** In strict mode, duplicate parameters will throw a Syntax Error.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 12. What is the output of below code

```javascript
const printNumbersArrow = (first, second, first) => {
  console.log(first, second, first);
};
printNumbersArrow(1, 2, 3);
```

- 1: 1, 2, 3
- 2: 3, 2, 3
- 3: SyntaxError: Duplicate parameter name not allowed in this context
- 4: 1, 2, 1

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

Unlike regular functions, the arrow functions doesn't not allow duplicate parameters in either strict or non-strict mode. So you can see `SyntaxError` in the console.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 13. What is the output of below code

```javascript
const arrowFunc = () => arguments.length;
console.log(arrowFunc(1, 2, 3));
```

- 1: ReferenceError: arguments is not defined
- 2: 3
- 3: undefined
- 4: null

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

Arrow functions do not have an `arguments, super, this, or new.target` bindings. So any reference to `arguments` variable tries to resolve to a binding in a lexically enclosing environment. In this case, the arguments variable is not defined outside of the arrow function. Hence, you will receive a reference error.

Where as the normal function provides the number of arguments passed to the function

```javascript
const func = function () {
  return arguments.length;
};
console.log(func(1, 2, 3));
```

But If you still want to use an arrow function then rest operator on arguments provides the expected arguments

```javascript
const arrowFunc = (...args) => args.length;
console.log(arrowFunc(1, 2, 3));
```

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 14. What is the output of below code

```javascript
console.log(String.prototype.trimLeft.name === "trimLeft");
console.log(String.prototype.trimLeft.name === "trimStart");
```

- 1: True, False
- 2: False, True

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

In order to be consistent with functions like `String.prototype.padStart`, the standard method name for trimming the whitespaces is considered as `trimStart`. Due to web web compatibility reasons, the old method name 'trimLeft' still acts as an alias for 'trimStart'. Hence, the prototype for 'trimLeft' is always 'trimStart'

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 15. What is the output of below code

```javascript
console.log(Math.max());
```

- 1: undefined
- 2: Infinity
- 3: 0
- 4: -Infinity

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

-Infinity is the initial comparant because almost every other value is bigger. So when no arguments are provided, -Infinity is going to be returned.
**Note:** Zero number of arguments is a valid case.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 16. What is the output of below code

```javascript
console.log(10 == [10]);
console.log(10 == [[[[[[[10]]]]]]]);
```

- 1: True, True
- 2: True, False
- 3: False, False
- 4: False, True

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

As per the comparison algorithm in the ECMAScript specification(ECMA-262), the above expression converted into JS as below

```javascript
10 === Number([10].valueOf().toString()); // 10
```

So it doesn't matter about number brackets([]) around the number, it is always converted to a number in the expression.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 17. What is the output of below code

```javascript
console.log(10 + "10");
console.log(10 - "10");
```

- 1: 20, 0
- 2: 1010, 0
- 3: 1010, 10-10
- 4: NaN, NaN

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

The concatenation operator(+) is applicable for both number and string types. So if any operand is string type then both operands concatenated as strings. Whereas subtract(-) operator tries to convert the operands as number type.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 18. What is the output of below code

```javascript
console.log([0] == false);
if ([0]) {
  console.log("I'm True");
} else {
  console.log("I'm False");
}
```

- 1: True, I'm True
- 2: True, I'm False
- 3: False, I'm True
- 4: False, I'm False

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

In comparison operators, the expression `[0]` converted to Number([0].valueOf().toString()) which is resolved to false. Whereas `[0]` just becomes a truthy value without any conversion because there is no comparison operator.

</p>
</details>

#### 19. What is the output of below code

```javascript
console.log([1, 2] + [3, 4]);
```

- 1: [1,2,3,4]
- 2: [1,2][3,4]
- 3: SyntaxError
- 4: 1,23,4

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The + operator is not meant or defined for arrays. So it converts arrays into strings and concatenates them.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 20. What is the output of below code

```javascript
const numbers = new Set([1, 1, 2, 3, 4]);
console.log(numbers);

const browser = new Set("Firefox");
console.log(browser);
```

- 1: {1, 2, 3, 4}, {"F", "i", "r", "e", "f", "o", "x"}
- 2: {1, 2, 3, 4}, {"F", "i", "r", "e", "o", "x"}
- 3: [1, 2, 3, 4], ["F", "i", "r", "e", "o", "x"]
- 4: {1, 1, 2, 3, 4}, {"F", "i", "r", "e", "f", "o", "x"}

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

Since `Set` object is a collection of unique values, it won't allow duplicate values in the collection. At the same time, it is case sensitive data structure.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 21. What is the output of below code

```javascript
console.log(NaN === NaN);
```

- 1: True
- 2: False

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

JavaScript follows IEEE 754 spec standards. As per this spec, NaNs are never equal for floating-point numbers.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 22. What is the output of below code

```javascript
let numbers = [1, 2, 3, 4, NaN];
console.log(numbers.indexOf(NaN));
```

- 1: 4
- 2: NaN
- 3: SyntaxError
- 4: -1

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The `indexOf` uses strict equality operator(===) internally and `NaN === NaN` evaluates to false. Since indexOf won't be able to find NaN inside an array, it returns -1 always.
But you can use `Array.prototype.findIndex` method to find out the index of NaN in an array or You can use `Array.prototype.includes` to check if NaN is present in an array or not.

```javascript
let numbers = [1, 2, 3, 4, NaN];
console.log(numbers.findIndex(Number.isNaN)); // 4

console.log(numbers.includes(NaN)); // true
```

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 23. What is the output of below code

```javascript
let [a, ...b,] = [1, 2, 3, 4, 5];
console.log(a, b);
```

- 1: 1, [2, 3, 4, 5]
- 2: 1, {2, 3, 4, 5}
- 3: SyntaxError
- 4: 1, [2, 3, 4]

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

When using rest parameters, trailing commas are not allowed and will throw a SyntaxError.
If you remove the trailing comma then it displays 1st answer

```javascript
let [a, ...b] = [1, 2, 3, 4, 5];
console.log(a, b); // 1, [2, 3, 4, 5]
```

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 25. What is the output of below code

```javascript
async function func() {
  return 10;
}
console.log(func());
```

- 1: Promise {\<fulfilled\>: 10}
- 2: 10
- 3: SyntaxError
- 4: Promise {\<rejected\>: 10}

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

Async functions always return a promise. But even if the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise. The above async function is equivalent to below expression,

```javascript
function func() {
  return Promise.resolve(10);
}
```

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 26. What is the output of below code

```javascript
async function func() {
  await 10;
}
console.log(func());
```

- 1: Promise {\<fulfilled\>: 10}
- 2: 10
- 3: SyntaxError
- 4: Promise {\<resolved\>: undefined}

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The await expression returns value 10 with promise resolution and the code after each await expression can be treated as existing in a `.then` callback. In this case, there is no return expression at the end of the function. Hence, the default return value of `undefined` is returned as the resolution of the promise. The above async function is equivalent to below expression,

```javascript
function func() {
  return Promise.resolve(10).then(() => undefined);
}
```

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 27. What is the output of below code

```javascript
function delay() {
  return new Promise(resolve => setTimeout(resolve, 2000));
}

async function delayedLog(item) {
  await delay();
  console.log(item);
}

async function processArray(array) {
  array.forEach(item => {
    await delayedLog(item);
  })
}

processArray([1, 2, 3, 4]);
```

- 1: SyntaxError
- 2: 1, 2, 3, 4
- 3: 4, 4, 4, 4
- 4: 4, 3, 2, 1

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

Even though ‚ÄúprocessArray‚Äù is an async function, the anonymous function that we use for `forEach` is synchronous. If you use await inside a synchronous function then it throws a syntax error.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 28. What is the output of below code

```javascript
function delay() {
  return new Promise((resolve) => setTimeout(resolve, 2000));
}

async function delayedLog(item) {
  await delay();
  console.log(item);
}

async function process(array) {
  array.forEach(async (item) => {
    await delayedLog(item);
  });
  console.log("Process completed!");
}
process([1, 2, 3, 5]);
```

- 1: 1 2 3 5 and Process completed!
- 2: 5 5 5 5 and Process completed!
- 3: Process completed! and 5 5 5 5
- 4: Process completed! and 1 2 3 5

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The forEach method will not wait until all items are finished but it just runs the tasks and goes next. Hence, the last statement is displayed first followed by a sequence of promise resolutions.

But you control the array sequence using for..of loop,

```javascript
async function processArray(array) {
  for (const item of array) {
    await delayedLog(item);
  }
  console.log("Process completed!");
}
```

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 29. What is the output of below code

```javascript
var set = new Set();
set.add("+0").add("-0").add(NaN).add(undefined).add(NaN);
console.log(set);
```

- 1: Set(4) {"+0", "-0", NaN, undefined}
- 2: Set(3) {"+0", NaN, undefined}
- 3: Set(5) {"+0", "-0", NaN, undefined, NaN}
- 4: Set(4) {"+0", NaN, undefined, NaN}

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

Set has few exceptions from equality check,

1. All NaN values are equal
2. Both +0 and -0 considered as different values

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 30. What is the output of below code

```javascript
const sym1 = Symbol("one");
const sym2 = Symbol("one");

const sym3 = Symbol.for("two");
const sym4 = Symbol.for("two");

console.log(sym1 === sym2, sym3 === sym4);
```

- 1: true, true
- 2: true, false
- 3: false, true
- 4: false, false

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

Symbol follows below conventions,

1. Every symbol value returned from Symbol() is unique irrespective of the optional string.
2. `Symbol.for()` function creates a symbol in a global symbol registry list. But it doesn't necessarily create a new symbol on every call, it checks first if a symbol with the given key is already present in the registry and returns the symbol if it is found. Otherwise a new symbol created in the registry.

**Note:** The symbol description is just useful for debugging purposes.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 31. What is the output of below code

```javascript
const sym1 = new Symbol("one");
console.log(sym1);
```

- 1: SyntaxError
- 2: one
- 3: Symbol('one')
- 4: Symbol

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

`Symbol` is a just a standard function and not an object constructor(unlike other primitives new Boolean, new String and new Number). So if you try to call it with the new operator will result in a TypeError

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 32. What is the output of below code

```javascript
let myNumber = 100;
let myString = "100";

if (!typeof myNumber === "string") {
  console.log("It is not a string!");
} else {
  console.log("It is a string!");
}

if (!typeof myString === "number") {
  console.log("It is not a number!");
} else {
  console.log("It is a number!");
}
```

- 1: SyntaxError
- 2: It is not a string!, It is not a number!
- 3: It is not a string!, It is a number!
- 4: It is a string!, It is a number!

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The return value of `typeof myNumber` or `typeof myString` is always a truthy value (either "number" or "string"). The ! operator operates on either `typeof myNumber` or `typeof myString`, converting them to boolean values. Since the value of both `!typeof myNumber` and `!typeof myString` is false, the if condition fails, and control goes to else block.

To make the ! operator operate on the equality expression, one needs to add parentheses:

```
if (!(typeof myNumber === "string"))
```

Or simply use the inequality operator:

```
if (typeof myNumber !== "string")
```

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 33. What is the output of below code

```javascript
console.log(
  JSON.stringify({ myArray: ["one", undefined, function () {}, Symbol("")] })
);
console.log(
  JSON.stringify({ [Symbol.for("one")]: "one" }, [Symbol.for("one")])
);
```

- 1: {"myArray":['one', undefined, {}, Symbol]}, {}
- 2: {"myArray":['one', null,null,null]}, {}
- 3: {"myArray":['one', null,null,null]}, "{ [Symbol.for('one')]: 'one' }, [Symbol.for('one')]"
- 4: {"myArray":['one', undefined, function(){}, Symbol('')]}, {}

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

The symbols has below constraints,

1. The undefined, Functions, and Symbols are not valid JSON values. So those values are either omitted (in an object) or changed to null (in an array). Hence, it returns null values for the value array.
2. All Symbol-keyed properties will be completely ignored. Hence it returns an empty object({}).

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 34. What is the output of below code

```javascript
class A {
  constructor() {
    console.log(new.target.name);
  }
}

class B extends A {
  constructor() {
    super();
  }
}

new A();
new B();
```

- 1: A, A
- 2: A, B

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Using constructors, `new.target` refers to the constructor (points to the class definition of class which is initialized) that was directly invoked by new. This also applies to the case if the constructor is in a parent class and was delegated from a child constructor.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 35. What is the output of below code

```javascript
const [x, ...y, z] = [1, 2, 3, 4];
console.log(x, y, z);
```

- 1: 1, [2, 3], 4
- 2: 1, [2, 3, 4], undefined
- 3: 1, [2], 3
- 4: SyntaxError

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

It throws a syntax error because the rest element should not have a trailing comma. You should always consider using a rest operator as the last element.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 36. What is the output of below code

```javascript
const { a: x = 10, b: y = 20 } = { a: 30 };

console.log(x);
console.log(y);
```

- 1: 30, 20
- 2: 10, 20
- 3: 10, undefined
- 4: 30, undefined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

The object property follows below rules,

1. The object properties can be retrieved and assigned to a variable with a different name
2. The property assigned a default value when the retrieved value is `undefined`

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 37. What is the output of below code

```javascript
function area({ length = 10, width = 20 }) {
  console.log(length * width);
}

area();
```

- 1: 200
- 2: Error
- 3: undefined
- 4: 0

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

If you leave out the right-hand side assignment for the destructuring object, the function will look for at least one argument to be supplied when invoked. Otherwise you will receive an error `Error: Cannot read property 'length' of undefined` as mentioned above.

You can avoid the error with either of the below changes,

1. **Pass at least an empty object:**

```javascript
function area({ length = 10, width = 20 }) {
  console.log(length * width);
}

area({});
```

2. **Assign default empty object:**

```javascript
function area({ length = 10, width = 20 } = {}) {
  console.log(length * width);
}

area();
```

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 38. What is the output of below code

```javascript
const props = [
  { id: 1, name: "John" },
  { id: 2, name: "Jack" },
  { id: 3, name: "Tom" },
];

const [, , { name }] = props;
console.log(name);
```

- 1: Tom
- 2: Error
- 3: undefined
- 4: John

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

It is possible to combine Array and Object destructuring. In this case, the third element in the array props accessed first followed by name property in the object.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 39. What is the output of below code

```javascript
function checkType(num = 1) {
  console.log(typeof num);
}

checkType();
checkType(undefined);
checkType("");
checkType(null);
```

- 1: number, undefined, string, object
- 2: undefined, undefined, string, object
- 3: number, number, string, object
- 4: number, number, number, number

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

If the function argument is set implicitly(not passing argument) or explicitly to undefined, the value of the argument is the default parameter. Whereas for other falsy values('' or null), the value of the argument is passed as a parameter.

Hence, the result of function calls categorized as below,

1. The first two function calls logs number type since the type of default value is number
2. The type of '' and null values are string and object type respectively.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 40. What is the output of below code

```javascript
function add(item, items = []) {
  items.push(item);
  return items;
}

console.log(add("Orange"));
console.log(add("Apple"));
```

- 1: ['Orange'], ['Orange', 'Apple']
- 2: ['Orange'], ['Apple']

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Since the default argument is evaluated at call time, a new object is created each time the function is called. So in this case, the new array is created and an element pushed to the default empty array.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 41. What is the output of below code

```javascript
function greet(greeting, name, message = greeting + " " + name) {
  console.log([greeting, name, message]);
}

greet("Hello", "John");
greet("Hello", "John", "Good morning!");
```

- 1: SyntaxError
- 2: ['Hello', 'John', 'Hello John'], ['Hello', 'John', 'Good morning!']

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Since parameters defined earlier are available to later default parameters, this code snippet doesn't throw any error.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 42. What is the output of below code

```javascript
function outer(f = inner()) {
  function inner() {
    return "Inner";
  }
}
outer();
```

- 1: ReferenceError
- 2: Inner

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

The functions and variables declared in the function body cannot be referred from default value parameter initializers. If you still try to access, it throws a run-time ReferenceError(i.e, `inner` is not defined).

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 43. What is the output of below code

```javascript
function myFun(x, y, ...manyMoreArgs) {
  console.log(manyMoreArgs);
}

myFun(1, 2, 3, 4, 5);
myFun(1, 2);
```

- 1: [3, 4, 5], undefined
- 2: SyntaxError
- 3: [3, 4, 5], []
- 4: [3, 4, 5], [undefined]

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

The rest parameter is used to hold the remaining parameters of a function and it becomes an empty array if the argument is not provided.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 44. What is the output of below code

```javascript
const obj = { key: "value" };
const array = [...obj];
console.log(array);
```

- 1: ['key', 'value']
- 2: TypeError
- 3: []
- 4: ['key']

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Spread syntax can be applied only to iterable objects. By default, Objects are not iterable, but they become iterable when used in an Array, or with iterating functions such as `map(), reduce(), and assign()`. If you still try to do it, it still throws `TypeError: obj is not iterable`.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 45. What is the output of below code

```javascript
function* myGenFunc() {
  yield 1;
  yield 2;
  yield 3;
}
var myGenObj = new myGenFunc();
console.log(myGenObj.next().value);
```

- 1: 1
- 2: undefined
- 3: SyntaxError
- 4: TypeError

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

Generators are not constructible type. But if you still proceed to do, there will be an error saying "TypeError: myGenFunc is not a constructor"

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 46. What is the output of below code

```javascript
function* yieldAndReturn() {
  yield 1;
  return 2;
  yield 3;
}

var myGenObj = yieldAndReturn();
console.log(myGenObj.next());
console.log(myGenObj.next());
console.log(myGenObj.next());
```

- 1: { value: 1, done: false }, { value: 2, done: true }, { value: undefined, done: true }
- 2: { value: 1, done: false }, { value: 2, done: false }, { value: undefined, done: true }
- 3: { value: 1, done: false }, { value: 2, done: true }, { value: 3, done: true }
- 4: { value: 1, done: false }, { value: 2, done: false }, { value: 3, done: true }

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

A return statement in a generator function will make the generator finish. If a value is returned, it will be set as the value property of the object and done property to true. When a generator is finished, subsequent next() calls return an object of this form: `{value: undefined, done: true}`.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 47. What is the output of below code

```javascript
const myGenerator = (function* () {
  yield 1;
  yield 2;
  yield 3;
})();
for (const value of myGenerator) {
  console.log(value);
  break;
}

for (const value of myGenerator) {
  console.log(value);
}
```

- 1: 1,2,3 and 1,2,3
- 2: 1,2,3 and 4,5,6
- 3: 1 and 1
- 4: 1

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The generator should not be re-used once the iterator is closed. i.e, Upon exiting a loop(on completion or using break & return), the generator is closed and trying to iterate over it again does not yield any more results. Hence, the second loop doesn't print any value.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 48. What is the output of below code

```javascript
const num = 0o38;
console.log(num);
```

- 1: SyntaxError
- 2: 38

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

If you use an invalid number(outside of 0-7 range) in the octal literal, JavaScript will throw a SyntaxError. In ES5, it treats the octal literal as a decimal number.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 49. What is the output of below code

```javascript
const squareObj = new Square(10);
console.log(squareObj.area);

class Square {
  constructor(length) {
    this.length = length;
  }

  get area() {
    return this.length * this.length;
  }

  set area(value) {
    this.area = value;
  }
}
```

- 1: 100
- 2: ReferenceError

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Unlike function declarations, class declarations are not hoisted. i.e, First You need to declare your class and then access it, otherwise it will throw a ReferenceError "Uncaught ReferenceError: Square is not defined".

**Note:** Class expressions also applies to the same hoisting restrictions of class declarations.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 50. What is the output of below code

```javascript
function Person() {}

Person.prototype.walk = function () {
  return this;
};

Person.run = function () {
  return this;
};

let user = new Person();
let walk = user.walk;
console.log(walk());

let run = Person.run;
console.log(run());
```

- 1: undefined, undefined
- 2: Person, Person
- 3: SyntaxError
- 4: Window, Window

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

When a regular or prototype method is called without a value for **this**, the methods return an initial this value if the value is not undefined. Otherwise global window object will be returned. In our case, the initial `this` value is undefined so both methods return window objects.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 51. What is the output of below code

```javascript
class Vehicle {
  constructor(name) {
    this.name = name;
  }

  start() {
    console.log(`${this.name} vehicle started`);
  }
}

class Car extends Vehicle {
  start() {
    console.log(`${this.name} car started`);
    super.start();
  }
}

const car = new Car("BMW");
console.log(car.start());
```

- 1: SyntaxError
- 2: BMW vehicle started, BMW car started
- 3: BMW car started, BMW vehicle started
- 4: BMW car started, BMW car started

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

The super keyword is used to call methods of a superclass. Unlike other languages the super invocation doesn't need to be a first statement. i.e, The statements will be executed in the same order of code.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 52. What is the output of below code

```javascript
const USER = { age: 30 };
USER.age = 25;
console.log(USER.age);
```

- 1: 30
- 2: 25
- 3: Uncaught TypeError
- 4: SyntaxError

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Even though we used constant variables, the content of it is an object and the object's contents (e.g properties) can be altered. Hence, the change is going to be valid in this case.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 53. What is the output of below code

```javascript
console.log("üôÇ" === "üôÇ");
```

- 1: false
- 2: true

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Emojis are unicodes and the unicode for smile symbol is "U+1F642". The unicode comparision of same emojies is equivalent to string comparison. Hence, the output is always true.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 54. What is the output of below code?

```javascript
console.log(typeof typeof typeof true);
```

- 1: string
- 2: boolean
- 3: NaN
- 4: number

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

The typeof operator on any primitive returns a string value. So even if you apply the chain of typeof operators on the return value, it is always string.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 55. What is the output of below code?

```javascript
let zero = new Number(0);

if (zero) {
  console.log("If");
} else {
  console.log("Else");
}
```

- 1: If
- 2: Else
- 3: NaN
- 4: SyntaxError

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

1. The type of operator on new Number always returns object. i.e, typeof new Number(0) --> object.
2. Objects are always truthy in if block

Hence the above code block always goes to if section.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 55. What is the output of below code in non strict mode?

```javascript
let msg = "Good morning!!";

msg.name = "John";

console.log(msg.name);
```

- 1: ""
- 2: Error
- 3: John
- 4: Undefined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

It returns undefined for non-strict mode and returns Error for strict mode. In non-strict mode, the wrapper object is going to be created and get the mentioned property. But the object get disappeared after accessing the property in next line.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 56. What is the output of below code?

```javascript
let count = 10;

(function innerFunc() {
  if (count === 10) {
    let count = 11;
    console.log(count);
  }
  console.log(count);
})();
```

- 1: 11, 10
- 2: 11, 11
- 3: 10, 11
- 4: 10, 10

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

11 and 10 is logged to the console.

The innerFunc is a closure which captures the count variable from the outerscope. i.e, 10. But the conditional has another local variable `count` which overwrites the ourter `count` variable. So the first console.log displays value 11.
Whereas the second console.log logs 10 by capturing the count variable from outerscope.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 57. What is the output of below code ?

- 1: console.log(true && 'hi');
- 2: console.log(true && 'hi' && 1);
- 3: console.log(true && '' && 0);

<details><summary><b>Answer</b></summary>
  
 - 1: hi
 - 2: 1
 - 3: ''
  
 Reason : The operator returns the value of the first falsy operand encountered when evaluating from left to right, or the value of the last operand if they are all truthy.

**Note:** Below these values are consider as falsy value

- 1: 0
- 2: ''
- 3: null
- 4: undefined
- 5: NAN

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 58. What is the output of below code ?

```javascript
let arr = [1, 2, 3];
let str = "1,2,3";

console.log(arr == str);
```

- 1: false
- 2: Error
- 3: true

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

Arrays have their own implementation of `toString` method that returns a comma-separated list of elements. So the above code snippet returns true. In order to avoid conversion of array type, we should use === for comparison.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 59. What is the output of below code?

```javascript
getMessage();

var getMessage = () => {
  console.log("Good morning");
};
```

- 1: Good morning
- 2: getMessage is not a function
- 3: getMessage is not defined
- 4: Undefined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Hoisting will move variables and functions to be the top of scope. Even though getMessage is an arrow function the above function will considered as a varible due to it's variable declaration or assignment. So the variables will have undefined value in memory phase and throws an error '`getMessage` is not a function' at the code execution phase.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 60. What is the output of below code?

```javascript
let quickPromise = Promise.resolve();

quickPromise.then(() => console.log("promise finished"));

console.log("program finished");
```

- 1: program finished
- 2: Cannot predict the order
- 3: program finished, promise finished
- 4: promise finished, program finished

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

Even though a promise is resolved immediately, it won't be executed immediately because its **.then/catch/finally** handlers or callbacks(aka task) are pushed into the queue. Whenever the JavaScript engine becomes free from the current program, it pulls a task from the queue and executes it. This is the reason why last statement is printed first before the log of promise handler.

**Note:** We call the above queue as "MicroTask Queue"

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 61. What is the output of below code?

```javascript
console
  .log("First line")
  [("a", "b", "c")].forEach((element) => console.log(element));
console.log("Third line");
```

- 1: `First line`, then print `a, b, c` in a new line, and finally print `Third line` as next line
- 2: `First line`, then print `a, b, c` in a first line, and print `Third line` as next line
- 3: Missing semi-colon error
- 4: Cannot read properties of undefined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

When JavaScript encounters a line break without a semicolon, the JavaScript parser will automatically add a semicolon based on a set of rules called `Automatic Semicolon Insertion` which determines whether line break as end of statement or not to insert semicolon. But it does not assume a semicolon before square brackets [...]. So the first two lines considered as a single statement as below.

```javascript
console
  .log("First line")
  [("a", "b", "c")].forEach((element) => console.log(element));
```

Hence, there will be **cannot read properties of undefined** error while applying the array square bracket on log function.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 62. Write a function that returns a random HEX color

<details><summary><b>Solution 1 (Iterative generation)</b></summary>
<p>

```javascript
const HEX_ALPHABET = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
];
const HEX_PREFIX = "#";
const HEX_LENGTH = 6;

function generateRandomHex() {
  let randomHex = "";

  for (let i = 0; i < HEX_LENGTH; i++) {
    const randomIndex = Math.floor(Math.random() * HEX_ALPHABET.length);
    randomHex += HEX_ALPHABET[randomIndex];
  }

  return HEX_PREFIX + randomHex;
}
```

</p>

</details>

<details><summary><b>Solution 2 (One-liner)</b></summary>
<p>

```javascript
const HEX_PREFIX = "#";
const HEX_RADIX = 16;
const HEX_LENGTH = 6;

function generateRandomHex() {
  return (
    HEX_PREFIX +
    Math.floor(Math.random() * 0xffffff)
      .toString(HEX_RADIX)
      .padStart(HEX_LENGTH, "0")
  );
}
```

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 63. What is the output of below code?

```javascript
var of = ["of"];
for (var of of of) {
  console.log(of);
}
```

- 1: of
- 2: SyntaxError: Unexpected token of
- 3: SyntaxError: Identifier 'of' has already been declared
- 4: ReferenceError: of is not defined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

In JavaScript, `of` is not considered as a reserved keyword. So the variable declaration with `of` is accepted and prints the array value `of` using for..of loop.

But if you use reserved keyword such as `in` then there will be a syntax error saying `SyntaxError: Unexpected token in`,

```javascript
var in = ['in'];
for(var in in in) {
  console.log(in[in]);
}
```

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 64. What is the output of below code?

```javascript
const numbers = [11, 25, 31, 23, 33, 18, 200];
numbers.sort();
console.log(numbers);
```

- 1: [11, 18, 23, 25, 31, 33, 200]
- 2: [11, 18, 200, 23, 25, 31, 33]
- 3: [11, 25, 31, 23, 33, 18, 200]
- 4: Cannot sort numbers

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

By default, the sort method sorts elements alphabetically. This is because elemented converted to strings and strings compared in UTF-16 code units order. Hence, you will see the above numbers not sorted as expected. In order to sort numerically just supply a comparator function which handles numeric sorts.

```javascript
const numbers = [11, 25, 31, 23, 33, 18, 200];
numbers.sort((a, b) => a - b);
console.log(numbers);
```

**Note:** Sort() method changes the original array.

</p>

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 65. What is the output order of below code?

```javascript
setTimeout(() => {
  console.log("1");
}, 0);
Promise.resolve("hello").then(() => console.log("2"));
console.log("3");
```

- 1: 1, 2, 3
- 2: 1, 3, 2
- 3: 3, 1, 2
- 4: 3, 2, 1

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

When the JavaScript engine parses the above code, the first two statements are asynchronous which will be executed later and third statement is synchronous statement which will be moved to callstack, executed and prints the number 3 in the console. Next, Promise is native in ES6 and it will be moved to Job queue which has high priority than callback queue in the execution order. At last, since setTimeout is part of WebAPI the callback function moved to callback queue and executed. Hence, you will see number 2 printed first followed by 1.

</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 66. What is the output of below code?

```javascript
console.log(name);
console.log(message());
var name = "John";
(function message() {
  console.log("Hello John: Welcome");
});
```

- 1: John, Hello John: Welcome
- 2: undefined, Hello John, Welcome
- 3: Reference error: name is not defined, Reference error: message is not defined
- 4: undefined, Reference error: message is not defined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

IIFE(Immediately Invoked Function Expression) is just like any other function expression which won't be hoisted. Hence, there will be a reference error for message call.
The behavior would be the same with below function expression of message1,

```javascript
console.log(name);
console.log(message());
var name = 'John';
var message = function () {
   console.log('Hello John: Welcome');
});
```

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 67. What is the output of below code?

```javascript
message();

function message() {
  console.log("Hello");
}
function message() {
  console.log("Bye");
}
```

- 1: Reference error: message is not defined
- 2: Hello
- 3: Bye
- 4: Compile time error

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

As part of hoisting, initially JavaScript Engine or compiler will store first function in heap memory but later rewrite or replaces with redefined function content.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 68. What is the output of below code?

```javascript
var currentCity = "NewYork";

var changeCurrentCity = function () {
  console.log("Current City:", currentCity);
  var currentCity = "Singapore";
  console.log("Current City:", currentCity);
};

changeCurrentCity();
```

- 1: NewYork, Singapore
- 2: NewYork, NewYork
- 3: undefined, Singapore
- 4: Singapore, Singapore

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

Due to hositing feature, the variables declared with `var` will have `undefined` value in the creation phase so the outer variable `currentCity` will get same `undefined` value. But after few lines of code JavaScript engine found a new function call(`changeCurrentCity()`) to update the current city with `var` re-declaration. Since each function call will create a new execution context, the same variable will have `undefined` value before the declaration and new value(`Singapore`) after the declarion. Hence, the value `undefined` print first followed by new value `Singapore` in the execution phase.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 69. What is the output of below code in an order?

```javascript
function second() {
  var message;
  console.log(message);
}

function first() {
  var message = "first";
  second();
  console.log(message);
}

var message = "default";
first();
console.log(message);
```

- 1: undefined, first, default
- 2: default, default, default
- 3: first, first, default
- 4: undefined, undefined, undefined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

Each context(global or functional) has it's own variable environment and the callstack of variables in a LIFO order. So you can see the message variable value from second, first functions in an order followed by global context message variable value at the end.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 70. What is the output of below code?

```javascript
var expressionOne = function functionOne() {
  console.log("functionOne");
};
functionOne();
```

- 1: functionOne is not defined
- 2: functionOne
- 3: console.log("functionOne")
- 4: undefined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

The function call `functionOne` is not going to be part of scope chain and it has it's own execution context with the enclosed variable environment. i.e, It won't be accessed from global context. Hence, there will be an error while invoking the function as `functionOne is not defined`.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 71. What is the output of below code?

```javascript
const user = {
  name: "John",
  eat() {
    console.log(this);
    var eatFruit = function () {
      console.log(this);
    };
    eatFruit();
  },
};
user.eat();
```

- 1: {name: "John", eat: f}, {name: "John", eat: f}
- 2: Window {...}, Window {...}
- 3: {name: "John", eat: f}, undefined
- 4: {name: "John", eat: f}, Window {...}

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

`this` keyword is dynamic scoped but not lexically scoped . In other words, it doesn't matter where `this` has been written but how it has been invoked really matter. In the above code snippet, the `user` object invokes `eat` function so `this` keyword refers to `user` object but `eatFruit` has been invoked by `eat` function and `this` will have default `Window` object.

The above pit fall fixed by three ways,

1. In ES6, the arrow function will make `this` keyword as lexically scoped. Since the surrounding object of `this` object is `user` object, the `eatFruit` function will contain `user` object for `this` object.

```javascript
const user = {
  name: "John",
  eat() {
    console.log(this);
    var eatFruit = () => {
      console.log(this);
    };
    eatFruit();
  },
};
user.eat();
```

The next two solutions have been used before ES6 introduced.

2.  It is possible create a reference of `this` into a separate variable and use that new variable inplace of `this` keyword inside `eatFruit` function. This is a common practice in jQuery and AngularJS before ES6 introduced.

```javascript
const user = {
  name: "John",
  eat() {
    console.log(this);
    var self = this;
    var eatFruit = () => {
      console.log(self);
    };
    eatFruit();
  },
};
user.eat();
```

3. The `eatFruit` function can bind explicitly with `this` keyword where it refers `Window` object.

```javascript
const user = {
  name: "John",
  eat() {
    console.log(this);
    var eatFruit = function () {
      console.log(this);
    };
    return eatFruit.bind(this);
  },
};
user.eat()();
```

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 72. What is the output of below code?

```javascript
let message = "Hello World!";
message[0] = "J";
console.log(message);

let name = "John";
name = name + " Smith";
console.log(name);
```

- 1: Jello World!, John Smith
- 2: Jello World!, John
- 3: Hello World!, John Smith
- 4: Hello World!, John

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

In JavaScript, primitives are immutable i.e. there is no way to change a primitive value once it gets created. So when you try to update the string's first character, there is no change in the string value and prints the same initial value `Hello World!`. Whereas in the later example, the concatenated value is re-assigned to the same variable which will result into creation of new memory block with the reference pointing to `John Smith` value and the old memory block value(`John`) will be garbage collected.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 73. What is the output of below code?

```javascript
let user1 = {
  name: "Jacob",
  age: 28,
};

let user2 = {
  name: "Jacob",
  age: 28,
};

console.log(user1 === user2);
```

- 1: True
- 2: False
- 3: Compile time error

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

In JavaScript, the variables such as objects, arrays and functions comes under pass by reference. When you try to compare two objects with same content, it is going to compare memory address or reference of those variables. These variables always create separate memory blocks hence the comparison is always going to return false value.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 74. What is the output of below code?

```javascript
function greeting() {
  setTimeout(function () {
    console.log(message);
  }, 5000);
  const message = "Hello, Good morning";
}
greeting();
```

- 1: Undefined
- 2: Reference error:
- 3: Hello, Good morning
- 4: null

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

The variable `message` is still treated as closure(since it has been used in inner function) eventhough it has been declared after setTimeout function. The function with in setTimeout function will be sent to WebAPI and the variable declaration executed with in 5 seconds with the assigned value. Hence, the text declared for the variable will be displayed.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 75. What is the output of below code?

```javascript
const a = new Number(10);
const b = 10;
console.log(a === b);
```

- 1: False
- 2: True

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

Eventhough both variables `a` and `b` refer a number value, the first declaration is based on constructor function and the type of the variable is going to be `object` type. Whereas the second declaration is primitive assignment with a number and the type is `number` type. Hence, the equality operator `===` will output `false` value.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 76. What is the type of below function?

```javascript
function add(a, b) {
  console.log("The input arguments are: ", a, b);
  return a + b;
}
```

- 1: Pure function
- 2: Impure function

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Eventhough the above function returns the same result for the same arguments(input) that are passed in the function, the `console.log()` statement causes a function to have side effects because it affects the state of an external code. i.e, the `console` object's state and depends on it to perform the job. Hence, the above function considered as impure function.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 77. What is the output of below code?

```javascript
const promiseOne = new Promise((resolve, reject) => setTimeout(resolve, 4000));
const promiseTwo = new Promise((resolve, reject) => setTimeout(reject, 4000));

Promise.all([promiseOne, promiseTwo]).then((data) => console.log(data));
```

- 1: [{status: "fullfilled", value: undefined}, {status: "rejected", reason: undefined}]
- 2: [{status: "fullfilled", value: undefined}, Uncaught(in promise)]
- 3: Uncaught (in promise)
- 4: [Uncaught(in promise), Uncaught(in promise)]

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

The above promises settled at the same time but one of them resolved and other one rejected. When you use `.all` method on these promises, the result will be short circuted by throwing an error due to rejection in second promise. But If you use `.allSettled` method then result of both the promises will be returned irrespective of resolved or rejected promise status without throwing any error.

```javascript
Promise.allSettled([promiseOne, promiseTwo]).then((data) => console.log(data));
```

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 78. What is the output of below code?

```javascript
try {
  setTimeout(() => {
    console.log("try block");
    throw new Error(`An exception is thrown`);
  }, 1000);
} catch (err) {
  console.log("Error: ", err);
}
```

- 1: try block, Error: An exception is thrown
- 2: Error: An exception is thrown
- 3: try block, Uncaught Error: Exception is thrown
- 4: Uncaught Error: Exception is thrown

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

If you put `setTimeout` and `setInterval` methods inside the try clause and an exception is thrown, the catch clause will not catch any of them. This is because the try...catch statement works synchronously, and the function in the above code is executed asynchronously after a certain period of time. Hence, you will see runtime exception without catching the error. To resolve this issue, you have to put the try...catch block inside the function as below,

```javascript
setTimeout(() => {
  try {
    console.log("try block");
    throw new Error(`An exception is thrown`);
  } catch (err) {
    console.log("Error: ", err);
  }
}, 1000);
```

You can use `.catch()` function in promises to avoid these issues with asynchronous code.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 79. What is the output of below code?

```javascript
let a = 10;
if (true) {
  let a = 20;
  console.log(a, "inside");
}
console.log(a, "outside");
```

- 1: 20, "inside" and 20, "outside"
- 2: 20, "inside" and 10, "outside"
- 3: 10, "inside" and 10, "outside"
- 4: 10, "inside" and 20, "outside"

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

The variable "a" declared inside "if" has block scope and does not affect the value of the outer "a" variable.

</p>
</details>

---

**[üîù Back to Top](#table-of-contents)**

#### 80. What is the output of below code?

```javascript
let arr = [1, 2, 3, 4, 5, -6, 7];
arr.length = 0;
console.log(arr);
```

- 1: 0
- 2: Undefined
- 3: null
- 4: [ ]

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The length of the array 'arr' has been set to 0, so the array becomes empty.

</p>
</details>
---

**[üîù Back to Top](#table-of-contents)**

#### 81. How do you verify two strings are anagrams or not?
An anagram is a word or phrase formed by rearranging all the letters of a different word or phrase exactly once. For example, the anagrams of "eat" word are "tea" and "ate".

You can split each word into characters, followed by sort action and later join them back. After that you can compare those two words to verify whether those two words are anagrams or not.

```javascript
function verifyAnagrams(word1, word2) {
  return word1.split("").sort().join("") === word2.split("").sort().join("")
}
console.log(verifyAnagrams("eat", "ate"));
```

**[üîù Back to Top](#table-of-contents)**

#### 82. What is the output of below code?

```javascript
printHello();

printMessage();

function printHello() {
  console.log('Hello')

  function printMessage() {
    console.log("Good day")
  }
}
```

- 1: Hello, Good day
- 2: Reference Error: printHello is not defined, Reference Error: printMessage is not defined
- 3: Reference Error: printHello is not defined, Good day
- 4: Hello, Reference Error: printMessage is not defined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The function `printHello` is hoisted to the top of the global scope and prints "Hello" to the console. Even `printMessage` function is hoisted, but it is lifted to the local scope(in "printHello") it was declared in. That is the reason you will endup with reference error for second function call.

But if the second function is invoked in the first function itself, there won't be any reference error.

```javascript
printHello();

function printHello() {
  printMessage();
  console.log('Hello')

  function printMessage() {
    console.log("Good day")
  }
}
```

</p>
</details>
---

**[üîù Back to Top](#table-of-contents)**

#### 83. What is the time taken to execute below timeout callback?

```javascript
  console.log("Start code");

  setTimeout(function() {
      console.log("Callback code");
  }, 5000);

  console.log("After callback");


  let startTime = new Date().getTime();
  let endTime = startTime;

  while(endTime <= startTime + 10000) {
      endTime = new Date().getTime();
  }

  console.log("End code");
```

- 1: > 10 sec
- 2: Immediately
- 3: < 10 sec
- 4: <= 5sec

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

Even though there is a timer of 5 seconds supplied to `setTimeout` callback, it won't get executed until the main thread is free and finished executing the remaining part of the code. In this example, the remaining code(while loop) takes 10seconds to finish it's execution. In the mean time, the callback will be stored in callback queue upon completion of its 5 seconds timer. After 10 seconds, the callback will be moved to callstack because the callstack is empty by poping out global execution context. 

</p>
</details>

**[üîù Back to Top](#table-of-contents)**

## Disclaimer

The questions provided in this repository are the summary of frequently asked questions across numerous companies. We cannot guarantee that these questions will actually be asked during your interview process, nor should you focus on memorizing all of them. The primary purpose is for you to get a sense of what some companies might ask ‚Äî do not get discouraged if you don't know the answer to all of them ‚Å†‚Äî that is ok!

Good luck with your interview üòä

---

      

